-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | ORM
--   
--   ORM library for PostgreSQL
@package orville
@version 0.8.3.0


module Database.Orville.Expr
data RawExpr
rawSql :: String -> RawExpr
class GenerateSql expr
generateSql :: GenerateSql expr => expr -> RawExpr
data Expr a
rawSqlExpr :: String -> Expr a
expr :: a -> Expr a
type NameExpr = Expr NameForm
data NameForm
unescapedName :: NameForm -> String
type SelectExpr = Expr SelectForm
data SelectForm
SelectForm :: NameForm -> Maybe NameForm -> SelectForm
[selectFormColumn] :: SelectForm -> NameForm
[selectFormAlias] :: SelectForm -> Maybe NameForm
selectColumn :: NameForm -> SelectForm
qualified :: QualifySql form => form -> String -> form
aliased :: SelectForm -> NameForm -> SelectForm


module Database.Orville.Conduit

-- | <a>selectConduit</a> provides a way to stream the results of a
--   <a>Select</a> query from the database one by one using the conduit
--   library. You can <a>fuse</a> the conduit built by this function with
--   your own conduit pipeline to handle rows individually in whatever
--   fashion you need (e.g. turning them into rows of CSV). This is useful
--   if you want to be able to process many rows one by one without loading
--   them all into memory at once. You can aggregate the results however
--   you require as part of the conduit processing and then use
--   <a>runConduit</a> (or <a>runConduitRes</a>) from the conduit library
--   to execute the processing pipeline. Alternatively, your web server
--   (<tt>wai</tt>, <tt>servant</tt>, etc) may provide support for
--   converting a conduit into a streaming HTTP response.
selectConduit :: (Monad m, MonadOrville conn m, MonadCatch m, MonadResource m) => Select row -> ConduitT () row m ()


module Database.Orville.PostgresSQL

-- | <a>createConnectionPool</a> allocates a pool of connections to a
--   PosgreSQL server. The returned pool can be used as the endpoint to
--   <a>newOrvilleEnv</a> to construct.
createConnectionPool :: Int -> NominalDiffTime -> Int -> String -> IO (Pool Connection)
data Pool a
data Connection


module Database.Orville.Select
data Select row
selectQuery :: FromSql row -> FromClause -> SelectOptions -> Select row
selectQueryTable :: TableDefinition readEntity writeEntity key -> SelectOptions -> Select readEntity
selectQueryRows :: [SelectExpr] -> FromClause -> SelectOptions -> Select [(String, SqlValue)]
selectQueryRaw :: FromSql row -> String -> [SqlValue] -> Select row
selectQueryRawRows :: String -> [SqlValue] -> Select [(String, SqlValue)]
selectQueryColumns :: [SelectExpr] -> FromSql row -> FromClause -> SelectOptions -> Select row
selectField :: FieldDefinition a -> SelectForm
data FromClause
fromClauseRaw :: String -> FromClause
fromClauseTableName :: String -> FromClause
fromClauseTable :: TableDefinition readEntity writeEntity key -> FromClause
runSelect :: MonadOrville conn m => Select row -> m [row]


module Database.Orville.Raw
selectSql :: MonadOrville conn m => String -> [SqlValue] -> FromSql result -> m [result]
selectSqlRows :: MonadOrville conn m => String -> [SqlValue] -> m ResultSet
decodeSqlRows :: MonadOrville conn m => FromSql result -> ResultSet -> m [result]
type ResultSet = [[(String, SqlValue)]]
updateSql :: MonadOrville conn m => String -> [SqlValue] -> m Integer
withConnection :: MonadOrville conn m => (conn -> m a) -> m a
withTransaction :: MonadOrville conn m => m a -> m a


module Database.Orville.Core

-- | A <a>TableDefinition</a> is the center of the Orville universe. A
--   <a>TableDefinition</a> defines the structure of a table in the
--   database and associates it with a Haskell datatype, usually a Haskell
--   record type. The <a>TableDefinition</a> must specify how the Haskell
--   type is converted to and from the database schema, as as well as
--   provide same basic utility functions required by Orville for
--   interacting with the Haskell datatype.
--   
--   Usually you will use <tt>TableParams</tt> to construct a
--   <a>TableDefinition</a> in a more concise way. This type is provided as
--   an escape hatch for any situations where <tt>TableParams</tt> is too
--   restrictive for the sql mapping required by a type.
data TableDefinition readEntity writeEntity key
TableDefinition :: String -> [SomeField] -> [String] -> FieldDefinition key -> FromSql readEntity -> ToSql writeEntity () -> readEntity -> key -> TableComments () -> TableDefinition readEntity writeEntity key

-- | The name of the table in the database.
[tableName] :: TableDefinition readEntity writeEntity key -> String

-- | A list of field definitions defining the table structure
[tableFields] :: TableDefinition readEntity writeEntity key -> [SomeField]

-- | A list of any columns that may be deleted from the table by Orville.
--   (Orville will never delete a column without being told it is safe)
[tableSafeToDelete] :: TableDefinition readEntity writeEntity key -> [String]

-- | The statically typed field definition that is the primary key.
--   Currently this field must still by listed in <a>tableFields</a>
[tablePrimaryKey] :: TableDefinition readEntity writeEntity key -> FieldDefinition key

-- | A definition of how to convert the haskell type from a sql row
[tableFromSql] :: TableDefinition readEntity writeEntity key -> FromSql readEntity

-- | A function to set the key on the entity
[tableToSql] :: TableDefinition readEntity writeEntity key -> ToSql writeEntity ()

-- | A function to get the key on the entity
[tableGetKey] :: TableDefinition readEntity writeEntity key -> readEntity -> key

-- | Any comments that might be interesting for developers to see. These
--   comments will get printed in the log if there is an erro while
--   attempting to migrate the table.
[tableComments] :: TableDefinition readEntity writeEntity key -> TableComments ()

-- | <a>mkTableDefinition</a> converts a <a>TableParams</a> to
--   <a>TableDefinition</a>. Usually this is used directly on a record
--   literal of the <a>TableParams</a>. For example:
--   
--   <pre>
--   data Foo key = Foo key { fooId :: Record }
--   myTable :: TableDefinition Foo
--   myTable = mkTableDefinition $
--     TableParams
--       { tblName = "foo"
--       , tblMapper = User <a>$</a> attrField fooId idField
--       , tableSafeToDelete = []
--       , tblSetKey = key foo -&gt; foo { fooId = key }
--       , tblGetKey = fooId
--       , tblComments = []
--       }
--   </pre>
mkTableDefinition :: TableParams readEntity writeEntity key -> TableDefinition readEntity writeEntity key
tableKeyToSql :: TableDefinition readEntity writeEntity key -> key -> SqlValue
tableKeyFromSql :: TableDefinition readEntity writeEntity key -> SqlValue -> Maybe key

-- | SqlType defines the mapping of a Haskell type (<tt>a</tt>) to a SQL
--   column type in the database. This includes both how to convert the
--   type to and from the raw values read from the database as well as the
--   schema information required to create and migrate columns using the
--   type.
data SqlType a
SqlType :: String -> Maybe String -> Bool -> SqlTypeId -> Maybe Int -> a -> SqlValue -> SqlValue -> Maybe a -> SqlType a

-- | The raw SQL DDL to use when creating/migrating columns of this type
--   (not including any NULL or NOT NULL declarations)
[sqlTypeDDL] :: SqlType a -> String

-- | The raw SQL DDL to use when creating/migrating columns with foreign
--   keys to this type. This is used foreignRefType to build a new SqlType
--   when making foreign key fields
[sqlTypeReferenceDDL] :: SqlType a -> Maybe String

-- | Indicates whether columns should be marked NULL or NOT NULL in the
--   database schema. If this is <a>True</a>, then <a>sqlTypeFromSql</a>
--   should provide a handling of <tt>SqlNull</tt> that returns an
--   <tt>a</tt>, not <a>Nothing</a>.
[sqlTypeNullable] :: SqlType a -> Bool

-- | <a>sqlTypeId</a> will be compared to the <tt>colType</tt> field found
--   in the <a>SqlColDesc</a> return by <tt>describeTable</tt> when
--   determining whether a column type change is required when migrating
--   the database.
[sqlTypeId] :: SqlType a -> SqlTypeId

-- | 'sqlTypeSqlSize will be compared to the <tt>colSize</tt> field found
--   in the <a>SqlColDesc</a> return by <tt>describeTable</tt> when
--   determining whether a column type change is required when migrating
--   the database.
[sqlTypeSqlSize] :: SqlType a -> Maybe Int

-- | A function for converting Haskell values of this type into values to
--   be stored in the database.
[sqlTypeToSql] :: SqlType a -> a -> SqlValue

-- | A function for converting values of this are stored in the database
--   into Haskell values. This function should return <a>Nothing</a> to
--   indicate an error if the conversion is impossible. Otherwise it should
--   return <a>Just</a> the corresponding <tt>a</tt> value.
[sqlTypeFromSql] :: SqlType a -> SqlValue -> Maybe a

-- | <a>serial</a> defines a 32-bit auto-incrementing column type. This
--   corresponds to the <a>SERIAL</a> type in PostgresSQL.
serial :: SqlType Int32

-- | <a>serial</a> defines a 64-bit auto-incrementing column type. This
--   corresponds to the <a>BIGSERIAL</a> type in PostgresSQL.
bigserial :: SqlType Int64

-- | <a>text</a> defines a fixed length text field type. This corresponds
--   to a "CHAR(len)" type in SQL.
text :: Int -> SqlType Text

-- | <a>varText</a> defines a variable text field type with a max length.
--   This corresponds to a "VARCHAR(len)" type in SQL.
varText :: Int -> SqlType Text

-- | <a>integer</a> defines a 32-bit integer type. This corresponds to the
--   <a>INTEGER</a> type in SQL.
integer :: SqlType Int32

-- | <a>bigInteger</a> defines a 64-bit integer type. This corresponds to
--   the <a>BIGINT</a> type in SQL.
bigInteger :: SqlType Int64

-- | <a>double</a> defines a floating point numeric type. This corresponds
--   to the "DOUBLE PRECISION" type in SQL.
double :: SqlType Double

-- | <a>boolean</a> defines a True/False boolean type. This corresponds to
--   the <a>BOOLEAN</a> type in SQL.
boolean :: SqlType Bool

-- | <a>date</a> defines a type representing a calendar date (without time
--   zone). It corresponds to the <a>DATE</a> type in SQL.
date :: SqlType Day

-- | <a>timestamp</a> defines a type representing a particular point in
--   time (without time zone). It corresponds to the "TIMESTAMP with time
--   zone" type in SQL.
--   
--   Note: This is NOT a typo. The "TIMESTAMP with time zone" type in SQL
--   does not include any actual time zone information. For an excellent
--   explanation of the complexities involving this type, please see Chris
--   Clark's blog post about it:
--   <a>http://blog.untrod.com/2016/08/actually-understanding-timezones-in-postgresql.html</a>
timestamp :: SqlType UTCTime

-- | <a>textSearchVector</a> defines a type for indexed text searching. It
--   corresponds to the <a>TSVECTOR</a> type in PostgresSQL.
textSearchVector :: SqlType Text

-- | <a>convertSqlType</a> changes the Haskell type used by a
--   <a>SqlType</a> in the same manner as <a>maybeConvertSqlType</a> in
--   cases where an <tt>a</tt> can always be converted to a <tt>b</tt>.
convertSqlType :: (b -> a) -> (a -> b) -> SqlType a -> SqlType b

-- | <a>maybeConvertSqlType</a> changes the Haskell type used by a
--   <a>SqlType</a> which changing the column type that will be used in the
--   database schema. The functions given will be used to convert the now
--   Haskell type to and from the original type when reading and writing
--   values from the database. When reading an <tt>a</tt> value from the
--   database, the conversion function should produce <a>Nothing</a> if the
--   value cannot be successfully converted to a <tt>b</tt>
maybeConvertSqlType :: (b -> a) -> (a -> Maybe b) -> SqlType a -> SqlType b

-- | <a>nullableType</a> creates a nullable version of an existing
--   <a>SqlType</a>. The underlying sql type will be the same as the
--   original, but column will be created with a <tt>NULL</tt> constraint
--   instead a 'NOT NULL' constraint. The Haskell value <a>Nothing</a> will
--   be used represent NULL values when converting to and from sql.
nullableType :: SqlType a -> SqlType (Maybe a)

-- | <a>TableParams</a> is the simplest way to make a
--   <a>TableDefinition</a>. You can use <a>mkTableDefinition</a> to make a
--   definition from the simplified params. Where <a>TableDefinition</a>
--   requires the <a>tableFields</a>, <a>tableFromSql</a>, and
--   <a>tableToSql</a> to all be defined separately and kept in sync,
--   <a>TableParams</a> provides a single <a>tblMapper</a> field that
--   specifies all three simultaneously and ensures they are consistent
--   with one another.
data TableParams readEntity writeEntity key
TableParams :: String -> RelationalMap writeEntity readEntity -> [String] -> FieldDefinition key -> readEntity -> key -> TableComments () -> TableParams readEntity writeEntity key

-- | The name of the table in the database
[tblName] :: TableParams readEntity writeEntity key -> String

-- | The relational mapping that defines how the Haskell entity type is
--   converted both to and from sql. The fields utilized in the mapping are
--   used to automatically build the list of <tt>FieldDefinitions</tt> that
--   define the structure of the table in the database.
[tblMapper] :: TableParams readEntity writeEntity key -> RelationalMap writeEntity readEntity

-- | A list of any columns that may be deleted from the table by Orville.
--   (Orville will never delete a column without being told it is safe)
[tblSafeToDelete] :: TableParams readEntity writeEntity key -> [String]

-- | A function to set the key on the entity
[tblPrimaryKey] :: TableParams readEntity writeEntity key -> FieldDefinition key

-- | A function to get the key on the entity
[tblGetKey] :: TableParams readEntity writeEntity key -> readEntity -> key

-- | Any comments that might be interesting for developers to see. These
--   comments will get printed in the log if there is an erro while
--   attempting to migrate the table.
[tblComments] :: TableParams readEntity writeEntity key -> TableComments ()
data RelationalMap a b
mapAttr :: (a -> b) -> RelationalMap b c -> RelationalMap a c
mapField :: FieldDefinition a -> RelationalMap a a
attrField :: (a -> b) -> FieldDefinition b -> RelationalMap a b
maybeMapper :: RelationalMap a b -> RelationalMap (Maybe a) (Maybe b)
prefixMap :: String -> RelationalMap a b -> RelationalMap a b
partialMap :: RelationalMap a (Either String a) -> RelationalMap a a
readOnlyMap :: RelationalMap a b -> RelationalMap c b
readOnlyField :: FieldDefinition a -> RelationalMap b a

-- | <a>OrvilleEnv</a> tracks all the environment information required for
--   an 'OrvilleT conn m' Monad to operate. Use <a>newOrvilleEnv</a> to
--   construct one.
data OrvilleEnv conn

-- | <a>newOrvilleEnv</a> initialized an <a>OrvilleEnv</a> for service. The
--   connection pool provided will be used to obtain connections to the
--   database ase required. You can use the <a>createConnectionPool</a>
--   utility function to create a connection pool to a PosgreSQL server.
newOrvilleEnv :: Pool conn -> OrvilleEnv conn
setStartTransactionSQL :: String -> OrvilleEnv conn -> OrvilleEnv conn
aroundRunningQuery :: (forall a. QueryType -> String -> IO a -> IO a) -> OrvilleEnv conn -> OrvilleEnv conn
addTransactionCallBack :: (TransactionEvent -> IO ()) -> OrvilleEnv conn -> OrvilleEnv conn
ormEnvPool :: OrvilleEnv conn -> Pool conn
data TransactionEvent
TransactionStart :: TransactionEvent
TransactionCommit :: TransactionEvent
TransactionRollback :: TransactionEvent
data OrvilleT conn m a
unOrvilleT :: OrvilleT conn m a -> ReaderT (OrvilleEnv conn) m a
data SqlValue

-- | <a>HasOrvilleContext</a> defines the operations that must be available
--   in your own monad for managing the connection pool that Orville
--   functions will use to access the database and manage transaction
--   state. In most cases you can include <a>OrvilleT</a> in your Monad
--   stack and then automatically derive an instance of
--   <a>HasOrvilleContext</a>.
--   
--   You could also provide your own implementations of these functions
--   instead of using <a>OrvilleT</a>, if that is the easiest approach for
--   your Monad.
class IConnection conn => HasOrvilleContext conn m | m -> conn

-- | getOrvilleEnv fetches the Orville environment from the Monad context.
--   Analogous to <a>ask</a> from the <tt>Reader</tt> monad.
getOrvilleEnv :: HasOrvilleContext conn m => m (OrvilleEnv conn)
localOrvilleEnv :: HasOrvilleContext conn m => (OrvilleEnv conn -> OrvilleEnv conn) -> m a -> m a

-- | <a>MonadOrville</a> does not have any methods of its own. Instead it
--   brings all the typeclass constraints required by Orville functions
--   that need to access the database into a single typeclass. In some
--   cases you can include <a>OrvilleT</a> in your Monad stack and then
--   automatically derive an instance of <a>MonadOrville</a>. However, more
--   likely you are using some third party monad somewhere in your stack
--   that does not han a <a>MonadOrvilleControl</a> instance. In this case
--   you won't be able to derive <a>MonadOrville</a>, but providing a
--   simple empty instance will do:
--   
--   <pre>
--   instance O.MonadOrville Postgres.Connection MyMonad
--   
--   </pre>
class (Monad m, MonadIO m, HasOrvilleContext conn m, MonadThrow m, MonadOrvilleControl m) => MonadOrville conn m
runOrville :: OrvilleT conn m a -> OrvilleEnv conn -> m a
mapOrvilleT :: Monad n => (m a -> n b) -> OrvilleT conn m a -> OrvilleT conn n b

-- | <a>MonadOrvilleControl</a> provides an interface for the kinds of IO
--   operations that Orville functions need to lift into the Monad
--   providing the <a>MonadOrville</a> instance. This typeclass allows
--   users to provide their own lifting strategies in case the Monad stack
--   in question has special needs. If you are only using <a>ReaderT</a>
--   and <a>OrvilleT</a> layers in your monad stack, you can probably
--   implement this for your own Monad wrapper type using the provided
--   default functions and providing functions to wrap and unwrapper your
--   Monad layer:
--   
--   <pre>
--   instance MonadOrvilleControl MyMonad where
--     liftWithConnection = defaultLiftWithConnection wrapMyMonad unWrapMyMonad
--     liftFinally = defaultLiftFinally wrapMyMonad unWrapMyMonad
--   
--   </pre>
--   
--   If you are using transformers in your monad stack beyond
--   <a>ReaderT</a>, they probably don't provide <a>MonadOrvilleControl</a>
--   instances (e.g. third party libraries). In this case, see
--   <a>MonadUnliftIO</a> for more help. If you're still stuck (because
--   your library doesn't support <tt>MonadTransControl</tt>), try
--   <a>MonadBaseControl</a> instead. If you're *still* stuck after that,
--   please file an issue on Github at
--   <a>https://github.com/flipstone/orville</a> so we can can help out!
class MonadOrvilleControl m
liftWithConnection :: MonadOrvilleControl m => (forall a. (conn -> IO a) -> IO a) -> (conn -> m b) -> m b
liftFinally :: MonadOrvilleControl m => (forall a b. IO a -> IO b -> IO a) -> m c -> m d -> m c

-- | defaultLiftWithConnection provides a simple definition of
--   <a>liftWithConnection</a> for <a>MonadOrvilleControl</a> instances
--   when the Monad in question is a wrapper around a type that already
--   implements <a>MonadOrvilleControl</a>
defaultLiftWithConnection :: MonadOrvilleControl m => (forall a. m a -> n a) -> (forall a. n a -> m a) -> (forall a. (conn -> IO a) -> IO a) -> (conn -> n b) -> n b

-- | defaultLiftFinally provides a simple definition of
--   <a>liftWithConnection</a> for <a>MonadOrvilleControl</a> instances
--   when the Monad in question is a wrapper around a type that already
--   implements <a>MonadOrvilleControl</a>
defaultLiftFinally :: MonadOrvilleControl m => (forall a. m a -> n a) -> (forall a. n a -> m a) -> (forall a b. IO a -> IO b -> IO a) -> n c -> n d -> n c
data QueryType
SelectQuery :: QueryType
InsertQuery :: QueryType
UpdateQuery :: QueryType
DeleteQuery :: QueryType
DDLQuery :: QueryType
withTransaction :: MonadOrville conn m => m a -> m a
data ColumnFlag
PrimaryKey :: ColumnFlag
Default :: a -> ColumnFlag
Unique :: ColumnFlag
References :: (TableDefinition readEntity writeEntity key) -> (FieldDefinition key) -> ColumnFlag
ColumnDescription :: String -> ColumnFlag
AssignedByDatabase :: ColumnFlag
data Now
Now :: Now
data ColumnType
AutomaticId :: ColumnType
ForeignId :: ColumnType
Text :: Int -> ColumnType
VarText :: Int -> ColumnType
Date :: ColumnType
Timestamp :: ColumnType
Integer :: ColumnType
BigInteger :: ColumnType
TextSearchVector :: ColumnType
Double :: ColumnType
Boolean :: ColumnType
data FieldDefinition a
fieldOfType :: SqlType a -> String -> FieldDefinition a
textField :: String -> Int -> FieldDefinition Text
fixedTextField :: String -> Int -> FieldDefinition Text
dayField :: String -> FieldDefinition Day
utcTimeField :: String -> FieldDefinition UTCTime
int32Field :: String -> FieldDefinition Int32
int64Field :: String -> FieldDefinition Int64
doubleField :: String -> FieldDefinition Double
boolField :: String -> FieldDefinition Bool
automaticIdField :: String -> FieldDefinition Int32
searchVectorField :: String -> FieldDefinition Text
nullableField :: FieldDefinition a -> FieldDefinition (Maybe a)
foreignKeyField :: String -> TableDefinition readEntity writeEntity key -> FieldDefinition key -> FieldDefinition key
withFlag :: FieldDefinition a -> ColumnFlag -> FieldDefinition a
withName :: FieldDefinition a -> String -> FieldDefinition a
withConversion :: FieldDefinition a -> (SqlType a -> SqlType b) -> FieldDefinition b
fieldFromSql :: FieldDefinition a -> FromSql a
fieldToSqlValue :: FieldDefinition a -> a -> SqlValue
data SomeField
SomeField :: (FieldDefinition a) -> SomeField
withPrefix :: FieldDefinition a -> String -> FieldDefinition a
fieldName :: FieldDefinition a -> String
fieldType :: FieldDefinition a -> SqlType a
fieldFlags :: FieldDefinition a -> [ColumnFlag]
data IndexDefinition
IndexDefinition :: String -> Bool -> String -> String -> IndexDefinition
[indexName] :: IndexDefinition -> String
[indexUnique] :: IndexDefinition -> Bool
[indexTable] :: IndexDefinition -> String
[indexBody] :: IndexDefinition -> String
uniqueIndex :: String -> TableDefinition readEntity writeEntity key -> [SomeField] -> IndexDefinition
simpleIndex :: String -> TableDefinition readEntity writeEntity key -> [SomeField] -> IndexDefinition
data ConstraintDefinition
ConstraintDefinition :: String -> String -> String -> ConstraintDefinition
[constraintName] :: ConstraintDefinition -> String
[constraintTable] :: ConstraintDefinition -> String
[constraintBody] :: ConstraintDefinition -> String
uniqueConstraint :: String -> TableDefinition readEntity writeEntity key -> [SomeField] -> ConstraintDefinition
dropConstraint :: TableDefinition readEntity writeEntity key -> String -> SchemaItem
data FromSql a
data FromSqlError
RowDataError :: String -> FromSqlError
QueryError :: String -> FromSqlError
class ColumnSpecifier col
selectForm :: ColumnSpecifier col => col -> SelectForm
col :: (ColumnSpecifier col, Convertible SqlValue a) => col -> FromSql a
data ToSql a b
getField :: Convertible a SqlValue => (entity -> a) -> ToSql entity ()
getComponent :: (entity -> a) -> ToSql a () -> ToSql entity ()
data SchemaItem
Table :: (TableDefinition readEntity writeEntity key) -> SchemaItem
DropTable :: String -> SchemaItem
Index :: IndexDefinition -> SchemaItem
DropIndex :: String -> SchemaItem
Constraint :: ConstraintDefinition -> SchemaItem
DropConstraint :: String -> String -> SchemaItem
type SchemaDefinition = [SchemaItem]
type Record = Int
type CreatedAt = UTCTime
type UpdatedAt = UTCTime
type OccurredAt = UTCTime
data TableComments a
noComments :: TableComments ()
say :: String -> (Int, Int, Int) -> String -> TableComments ()
data WhereCondition
whereAnd :: [WhereCondition] -> WhereCondition
whereOr :: [WhereCondition] -> WhereCondition
whereIn :: FieldDefinition a -> [a] -> WhereCondition
whereLike :: FieldDefinition a -> String -> WhereCondition
whereLikeInsensitive :: FieldDefinition a -> String -> WhereCondition
whereNotIn :: FieldDefinition a -> [a] -> WhereCondition
whereQualified :: TableDefinition a b c -> WhereCondition -> WhereCondition
whereRaw :: String -> [SqlValue] -> WhereCondition
isNull :: FieldDefinition a -> WhereCondition
isNotNull :: FieldDefinition a -> WhereCondition
(.==) :: FieldDefinition a -> a -> WhereCondition
(.<>) :: FieldDefinition a -> a -> WhereCondition
(.<-) :: FieldDefinition a -> [a] -> WhereCondition
(%==) :: FieldDefinition a -> a -> WhereCondition
(.>) :: FieldDefinition a -> a -> WhereCondition
(.>=) :: FieldDefinition a -> a -> WhereCondition
(.<) :: FieldDefinition a -> a -> WhereCondition
(.<=) :: FieldDefinition a -> a -> WhereCondition
data SelectOptions
SelectOptions :: First Bool -> [WhereCondition] -> [OrderByClause] -> First Int -> First Int -> [GroupByClause] -> SelectOptions
[selectDistinct] :: SelectOptions -> First Bool
[selectOptWhere] :: SelectOptions -> [WhereCondition]
[selectOptOrder] :: SelectOptions -> [OrderByClause]
[selectOptLimit] :: SelectOptions -> First Int
[selectOptOffset] :: SelectOptions -> First Int
[selectOptGroup] :: SelectOptions -> [GroupByClause]
where_ :: WhereCondition -> SelectOptions
distinct :: SelectOptions
order :: ToOrderBy a => a -> SortDirection -> SelectOptions
limit :: Int -> SelectOptions
offset :: Int -> SelectOptions
groupBy :: ToGroupBy a => a -> SelectOptions

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>
data FieldUpdate
fieldUpdate :: FieldDefinition a -> a -> FieldUpdate
(.:=) :: FieldDefinition a -> a -> FieldUpdate
data OrderByClause
OrderByClause :: String -> [SqlValue] -> SortDirection -> OrderByClause
data SortDirection
Ascending :: SortDirection
Descending :: SortDirection

-- | migrateSchema will attempt to make changes to the actual database
--   schema that it it matches the provided SchemaDefinition. Unsafe
--   migrations such as dropping tables or columns are never attempted
--   unless the SchemaDefinition explicitly states that the items are safe
--   to drop. Column types may be changed, but will fail if the database
--   cannot successfully make the request type change.
migrateSchema :: MonadOrville conn m => SchemaDefinition -> m ()
data MigrationError
MigrationLockExcessiveRetryError :: String -> MigrationError
MigrationExecutionError :: SchemaItem -> SomeException -> MigrationError

-- | generateMigrationPlan inspects the state of the actual database schema
--   and constructs a plan describing what changes would be made to make it
--   match the provided SchemaDefinition. If the actual schema already
--   matches the definition, Nothing will be returned.
generateMigrationPlan :: MonadOrville conn m => SchemaDefinition -> m (Maybe MigrationPlan)
data MigrationPlan
data MigrationItem
MigrationItem :: SchemaItem -> DDL -> MigrationItem
[migrationItemSchemaItem] :: MigrationItem -> SchemaItem
[migrationItemDDL] :: MigrationItem -> DDL
migrationPlanItems :: MigrationPlan -> [MigrationItem]
selectAll :: MonadOrville conn m => TableDefinition readEntity writeEntity key -> SelectOptions -> m [readEntity]
selectFirst :: MonadOrville conn m => TableDefinition readEntity writeEntity key -> SelectOptions -> m (Maybe readEntity)
deleteRecord :: MonadOrville conn m => TableDefinition readEntity writeEntity key -> key -> m ()
deleteWhere :: MonadOrville conn m => TableDefinition readEntity writeEntity key -> [WhereCondition] -> m Integer
findRecord :: MonadOrville conn m => TableDefinition readEntity writeEntity key -> key -> m (Maybe readEntity)
findRecords :: (Ord key, MonadOrville conn m) => TableDefinition readEntity writeEntity key -> [key] -> m (Map key readEntity)
findRecordsBy :: (Ord fieldValue, MonadOrville conn m) => TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> SelectOptions -> m (Map fieldValue [readEntity])
insertRecord :: MonadOrville conn m => TableDefinition readEntity writeEntity key -> writeEntity -> m readEntity
insertRecordMany :: MonadOrville conn m => TableDefinition readEntity writeEntity key -> [writeEntity] -> m ()
updateFields :: MonadOrville conn m => TableDefinition readEntity writeEntity key -> [FieldUpdate] -> [WhereCondition] -> m Integer
updateRecord :: MonadOrville conn m => TableDefinition readEntity writeEntity key -> key -> writeEntity -> m ()


module Database.Orville.Popper
data PopError
MissingRecord :: (TableDefinition readEntity writeEntity key) -> (FieldDefinition fieldValue) -> fieldValue -> PopError
Unpoppable :: String -> PopError
data Popper a b
data Popped a
PoppedValue :: a -> Popped a
PoppedError :: PopError -> Popped a

-- | Left-to-right composition
(>>>) :: Category cat => cat a b -> cat b c -> cat a c
infixr 1 >>>

-- | Right-to-left composition
(<<<) :: Category cat => cat b c -> cat a b -> cat a c
infixr 1 <<<
abortPop :: PopError -> Popper a b
certainly :: PopError -> Popper (Maybe b) b
certainly' :: Popper a PopError -> Popper a (Maybe b) -> Popper a b
fromKern :: (a -> b) -> Popper a b
hasMany :: Ord fieldValue => TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> Popper fieldValue [readEntity]
hasManyIn :: Ord fieldValue => TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> Popper [fieldValue] (Map fieldValue [readEntity])
hasOneIn :: Ord fieldValue => TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> Popper [fieldValue] (Map fieldValue readEntity)
hasManyInWhere :: Ord fieldValue => TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> SelectOptions -> Popper [fieldValue] (Map fieldValue [readEntity])
hasManyWhere :: Ord fieldValue => TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> SelectOptions -> Popper fieldValue [readEntity]
hasOne :: Ord fieldValue => TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> Popper fieldValue (Maybe readEntity)
hasOne' :: Ord fieldValue => TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> Popper fieldValue readEntity
hasOneWhere :: Ord fieldValue => TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> SelectOptions -> Popper fieldValue (Maybe readEntity)
kern :: Popper a a
missingRecordMessage :: TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> fieldValue -> String
popMissingRecord :: TableDefinition readEntity writeEntity key -> FieldDefinition fieldValue -> Popper fieldValue PopError
onKern :: (a -> b -> c) -> Popper b a -> Popper b c
pop :: MonadOrville conn m => Popper a b -> a -> m (Popped b)
popThrow :: MonadOrville conn m => Popper a b -> a -> m b
popFirst :: TableDefinition readEntity writeEntity key -> SelectOptions -> Popper a (Maybe readEntity)
popMany :: Popper a b -> Popper [a] [b]
onPopMany :: Popper a b -> Popper [a] [b] -> Popper a b
popMaybe :: Popper a b -> Popper (Maybe a) (Maybe b)

-- | popQuery embeds an Orville operation in a popper. It is left up to the
--   programmer to ensure that the Orville operation does not do any
--   updates to the database, but only does queries.
--   
--   The initial string argument is a description of the query to put into
--   the results of <a>explain</a>
popQuery :: String -> (forall conn m. MonadOrville conn m => m b) -> Popper a b
popRecord :: TableDefinition readEntity writeEntity key -> key -> Popper a (Maybe readEntity)
popRecord' :: TableDefinition readEntity writeEntity key -> key -> Popper a readEntity
popTable :: TableDefinition readEntity writeEntity key -> SelectOptions -> Popper a [readEntity]
explain :: Popper a b -> String
explainLines :: Popper a b -> [String]
instance GHC.Base.Functor (Database.Orville.Popper.Popper a)
instance GHC.Base.Applicative (Database.Orville.Popper.Popper a)
instance Control.Category.Category Database.Orville.Popper.Popper
instance Control.Arrow.Arrow Database.Orville.Popper.Popper
instance Control.Arrow.ArrowChoice Database.Orville.Popper.Popper
instance GHC.Base.Functor Database.Orville.Popper.Popped
instance GHC.Base.Applicative Database.Orville.Popper.Popped
instance GHC.Show.Show Database.Orville.Popper.PopError
instance GHC.Exception.Exception Database.Orville.Popper.PopError


module Database.Orville

module Database.Orville.Trigger
insertTriggered :: (MonadThrow m, MonadOrville conn m, MonadTrigger trigger m, InsertTrigger trigger readEntity) => TableDefinition readEntity writeEntity key -> writeEntity -> m readEntity
class InsertTrigger trigger readEntity
insertTriggers :: InsertTrigger trigger readEntity => readEntity -> [trigger]
updateTriggered :: (MonadThrow m, MonadOrville conn m, MonadTrigger trigger m, UpdateTrigger trigger readEntity writeEntity) => TableDefinition readEntity writeEntity key -> readEntity -> writeEntity -> m ()
class UpdateTrigger trigger readEntity writeEntity
updateTriggers :: UpdateTrigger trigger readEntity writeEntity => readEntity -> writeEntity -> [trigger]
deleteTriggered :: (MonadThrow m, MonadOrville conn m, MonadTrigger trigger m, DeleteTrigger trigger readEntity) => TableDefinition readEntity writeEntity key -> readEntity -> m ()
class DeleteTrigger trigger readEntity
deleteTriggers :: DeleteTrigger trigger readEntity => readEntity -> [trigger]
class MonadTrigger trigger m | m -> trigger
runTriggers :: MonadTrigger trigger m => [trigger] -> m ()
data OrvilleTriggerT trigger conn m a
data RecordedTriggers trigger
committedTriggers :: RecordedTriggers trigger -> [trigger]
uncommittedTriggers :: RecordedTriggers trigger -> Maybe [trigger]
runOrvilleTriggerT :: (MonadIO m) => OrvilleTriggerT trigger conn m a -> Pool conn -> m (a, [trigger])
askTriggers :: MonadIO m => OrvilleTriggerT trigger conn m (RecordedTriggers trigger)
clearTriggers :: MonadIO m => OrvilleTriggerT trigger conn m ()


-- | <a>MonadUnliftIO</a> provides functions and instances for using
--   <tt>MonadOrville</tt> and <tt>OrvilleT</tt> for Monad transformer
--   stacks that are using <tt>MonadUnliftIO</tt>. The most common way to
--   do this is simply to add the following <tt>MonadOrvilleControl</tt>
--   instance:
--   
--   <pre>
--   instance MonadOrvilleControl MyMonad where
--     liftWithConnection = liftWithConnectionViaUnliftIO
--     liftFinally = liftFinallyViaUnliftIO
--   </pre>
--   
--   This module also provides a <tt>MonadUnliftIO</tt> instance for
--   <tt>OrvilleT</tt> and <tt>OrvilleTrigger</tt>. |
module Database.Orville.MonadUnliftIO

-- | liftWithConnectionViaUnliftIO can be use as the implementation of
--   <tt>liftWithConnection</tt> for <tt>MonadOrvilleControl</tt> when the
--   <a>Monad</a> implements <tt>MonadUnliftIO</tt>. |
liftWithConnectionViaUnliftIO :: MonadUnliftIO m => (forall a. (conn -> IO a) -> IO a) -> (conn -> m b) -> m b

-- | liftFinallyViaUnliftIO can be use as the implementation of
--   <tt>liftFinally</tt> for <tt>MonadOrvilleControl</tt> when the
--   <a>Monad</a> implements <tt>MonadUnliftIO</tt>. |
liftFinallyViaUnliftIO :: MonadUnliftIO m => (forall a b. IO a -> IO b -> IO a) -> m c -> m d -> m c
instance Control.Monad.IO.Unlift.MonadUnliftIO m => Control.Monad.IO.Unlift.MonadUnliftIO (Database.Orville.Internal.Monad.OrvilleT conn m)
instance Control.Monad.IO.Unlift.MonadUnliftIO m => Control.Monad.IO.Unlift.MonadUnliftIO (Database.Orville.Internal.Trigger.OrvilleTriggerT trigger conn m)


-- | <a>ResourceT</a> provides <a>ResourceT</a> instance of the Orville
--   typeclasses for situations where you might need it. In particular, if
--   you are using the conduit library, you may want to wrap
--   <a>ResourceT</a> around your normal monad stack, in which case you'll
--   need the <tt>MonadOrville</tt> instance provided here to use
--   <tt>selectConduit</tt>.
--   
--   These instances are not included in the default exports for Orville
--   because the required either a <a>MonadUnliftIO</a> or
--   <tt>MonadBaseControl</tt> instance of the monad underlying
--   <a>ResourceT</a>, depending on the version of <a>ResourceT</a> you are
--   using. For resource-1.1.10 and above you must provide
--   <a>MonadUnliftIO</a> instance. For versions prior to 1.1.10 you must
--   provide a <tt>MonadBaseControl</tt> instance.
--   
--   This is required by <tt>MonadOrville</tt> requires an instance to
--   <tt>MonadBaseControl</tt> to be defined. The instance provided here
--   can only use one lifting strategy, one we choose <a>MonadUnliftIO</a>
--   wherever possible (both by our own opinion and because later versions
--   of <a>ResourceT</a> have removed <tt>MonadBaseControl</tt> support).
--   <tt>MonadBaseControl</tt> is used for versions of <a>ResourceT</a>
--   before <a>ResourceT</a> supported <a>MonadUnliftIO</a>.
module Database.Orville.ResourceT
instance (GHC.Base.Monad m, Database.Orville.Internal.Monad.HasOrvilleContext conn m) => Database.Orville.Internal.Monad.HasOrvilleContext conn (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance (Database.Orville.Internal.Monad.MonadOrvilleControl m, Control.Monad.IO.Unlift.MonadUnliftIO m) => Database.Orville.Internal.Monad.MonadOrvilleControl (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance (Control.Monad.IO.Unlift.MonadUnliftIO m, Database.Orville.Internal.Monad.MonadOrville conn m) => Database.Orville.Internal.Monad.MonadOrville conn (Control.Monad.Trans.Resource.Internal.ResourceT m)


-- | <a>MonadBaseControl</a> provides functions and instances for using
--   <tt>MonadOrville</tt> and <tt>OrvilleT</tt> for situations where you
--   need to use <tt>MonadBaseControl</tt>. If you do not know if you need
--   <tt>MonadBaseControl</tt>, then you probably don't need to use this
--   module. If you are thinking about using <tt>MonadBaseControl</tt>
--   instead of <tt>MonadUnliftIO</tt>, we recommend reading Michael
--   Snoyman's excellent "A Tale of Two Brackets"
--   (https:/<i>www.fpcomplete.com</i>blog<i>2017</i>06/tale-of-two-brackets)
--   if you have not already done so.
--   
--   If you're still here after reading above, this module provides the
--   functions you need to implement <tt>MonadOrvilleControl</tt> for your
--   Monad stack using its <tt>MonadBaseControl</tt> instance. The most
--   common way to do this is simply to add the following
--   <tt>MonadOrvilleControl</tt> instance:
--   
--   <pre>
--   instance MonadOrvilleControl MyMonad where
--     liftWithConnection = liftWithConnectionViaBaseControl
--     liftFinally = liftFinallyViaBaseControl
--   </pre>
--   
--   This module also provides a <tt>MonadOrvilleControl</tt> for
--   <a>StateT</a> as well as <tt>MonadBaseControl</tt> and
--   <tt>MonadTransControl</tt> instances for <tt>OrvilleT</tt> and
--   <tt>OrvilleTriggerT</tt>.
module Database.Orville.MonadBaseControl

-- | liftWithConnectionViaBaseControl can be use as the implementation of
--   <tt>liftWithConnection</tt> for <tt>MonadOrvilleControl</tt> when the
--   <a>Monad</a> implements <tt>MonadBaseControl</tt>.
liftWithConnectionViaBaseControl :: MonadBaseControl IO m => (forall b. (conn -> IO b) -> IO b) -> (conn -> m a) -> m a

-- | liftFinallyViaBaseControl can be use as the implementation of
--   'liftFinally for <tt>MonadOrvilleControl</tt> when the <a>Monad</a>
--   implements <tt>MonadBaseControl</tt>.
liftFinallyViaBaseControl :: MonadBaseControl IO m => (forall c d. IO c -> IO d -> IO c) -> m a -> m b -> m a
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO m => Database.Orville.Internal.Monad.MonadOrvilleControl (Control.Monad.Trans.State.Lazy.StateT a m)
instance Control.Monad.Trans.Control.MonadTransControl (Database.Orville.Internal.Monad.OrvilleT conn)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Database.Orville.Internal.Monad.OrvilleT conn m)
instance Control.Monad.Trans.Control.MonadTransControl (Database.Orville.Internal.Trigger.OrvilleTriggerT trigger conn)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Database.Orville.Internal.Trigger.OrvilleTriggerT trigger conn m)
